@startuml 核心类图
!theme plain
skinparam linetype ortho

package "Domain Model" {
  class PlanAggregate {
    - String planId
    - String version
    - PlanStatus status
    - Integer maxConcurrency
    - List<TaskAggregate> tasks
    - LocalDateTime createdAt
    - LocalDateTime startedAt
    - LocalDateTime endedAt
    - String failureSummary
    - double progress
    + addTask(TaskAggregate)
    + getTasks(): List<TaskAggregate>
  }

  class TaskAggregate {
    - String taskId
    - String planId
    - String tenantId
    - Long deployUnitId
    - Long deployUnitVersion
    - String deployUnitName
    - TaskStatus status
    - int currentStageIndex
    - int retryCount
    - Integer maxRetry
    - TaskCheckpoint checkpoint
    - List<StageResult> stageResults
    - LocalDateTime createdAt
    - LocalDateTime startedAt
    - LocalDateTime endedAt
    - TenantDeployConfigSnapshot prevConfigSnapshot
    - Long lastKnownGoodVersion
    - Long durationMillis
    + getters/setters()
  }

  class TenantDeployConfigSnapshot {
    - Long deployUnitId
    - Long deployUnitVersion
    - String deployUnitName
    - List<NetworkEndpoint> endpoints
  }

  class TaskCheckpoint {
    - String taskId
    - int lastCompletedStageIndex
    - List<String> completedStageNames
    - LocalDateTime timestamp
  }

  enum TaskStatus {
    CREATED
    VALIDATING
    VALIDATION_FAILED
    PENDING
    RUNNING
    PAUSED
    RESUMING
    COMPLETED
    FAILED
    ROLLING_BACK
    ROLLED_BACK
    ROLLBACK_FAILED
    CANCELLED
  }

  enum PlanStatus {
    CREATED
    VALIDATING
    READY
    RUNNING
    PAUSED
    PARTIAL_FAILED
    COMPLETED
    ROLLING_BACK
    ROLLED_BACK
    FAILED
    CANCELLED
  }

  PlanAggregate "1" *-- "many" TaskAggregate
  TaskAggregate --> TaskStatus
  TaskAggregate --> TenantDeployConfigSnapshot
  TaskAggregate --> TaskCheckpoint
  PlanAggregate --> PlanStatus
}

package "State Machine" {
  class TaskStateMachine {
    - TaskStatus current
    - Map<TaskStatus, Set<TaskStatus>> rules
    - Map<String, List<Guard>> guards
    - Map<String, List<Action>> actions
    + registerGuard(from, to, guard)
    + registerAction(from, to, action)
    + canTransition(to, ctx): boolean
    + transitionTo(to, ctx): TaskStatus
    + getCurrent(): TaskStatus
  }

  interface TransitionGuard<T> {
    + canTransition(T context): boolean
  }

  interface TransitionAction<T> {
    + onTransition(T context)
  }

  class TaskTransitionContext {
    - TaskAggregate aggregate
    - TaskRuntimeContext context
    - int totalStages
    + getAggregate(): TaskAggregate
    + getContext(): TaskRuntimeContext
    + getTotalStages(): int
  }

  class TaskStateManager {
    - Map<String, TaskStateMachine> stateMachines
    - Map<String, Long> sequences
    - Map<String, TaskAggregate> aggregates
    - Map<String, TaskRuntimeContext> runtimeContexts
    - Map<String, Integer> totalStagesMap
    - ApplicationEventPublisher eventPublisher
    - RollbackHealthVerifier rollbackHealthVerifier
    + initializeTask(taskId, status)
    + registerTaskAggregate(taskId, aggregate, ctx, totalStages)
    + updateState(taskId, newStatus)
    + updateState(taskId, newStatus, failureInfo)
    + getState(taskId): TaskStatus
    + nextSequence(taskId): long
  }

  TaskStateMachine --> TransitionGuard
  TaskStateMachine --> TransitionAction
  TaskStateManager "1" *-- "many" TaskStateMachine
  TaskStateManager --> TaskTransitionContext
}

package "Stage & Step" {
  interface TaskStage {
    + getName(): String
    + execute(TaskRuntimeContext): StageExecutionResult
    + canSkip(TaskRuntimeContext): boolean
  }

  class CompositeServiceStage {
    - String name
    - List<StageStep> steps
    + execute(TaskRuntimeContext): StageExecutionResult
    + canSkip(TaskRuntimeContext): boolean
  }

  interface StageStep {
    + execute(TaskRuntimeContext): StepExecutionResult
  }

  class ConfigUpdateStep {
    - String targetVersion
    + execute(TaskRuntimeContext): StepExecutionResult
  }

  class BroadcastStep {
    - String eventType
    + execute(TaskRuntimeContext): StepExecutionResult
  }

  class HealthCheckStep {
    - HealthCheckClient client
    - String expectedVersion
    - List<NetworkEndpoint> endpoints
    - int intervalSeconds
    - int maxAttempts
    + execute(TaskRuntimeContext): StepExecutionResult
  }

  interface StageFactory {
    + createStages(TaskAggregate, TenantDeployConfig, \n                ExecutorProperties, HealthCheckClient): List<TaskStage>
  }

  class DefaultStageFactory {
    + createStages(...): List<TaskStage>
  }

  TaskStage <|.. CompositeServiceStage
  CompositeServiceStage "1" *-- "many" StageStep
  StageStep <|.. ConfigUpdateStep
  StageStep <|.. BroadcastStep
  StageStep <|.. HealthCheckStep
  StageFactory <|.. DefaultStageFactory
  DefaultStageFactory ..> CompositeServiceStage
}

package "Execution" {
  class TaskExecutor {
    - String planId
    - TaskAggregate task
    - List<TaskStage> stages
    - TaskRuntimeContext context
    - CheckpointService checkpointService
    - TaskEventSink eventSink
    - int progressIntervalSeconds
    - TaskStateManager stateManager
    - ConflictRegistry conflicts
    - MetricsRegistry metrics
    - HeartbeatScheduler heartbeatScheduler
    + execute(): TaskExecutionResult
    + getCurrentStageName(): String
  }

  class HeartbeatScheduler {
    - TaskAggregate task
    - TaskEventSink eventSink
    - int totalStages
    - int intervalSeconds
    - MetricsRegistry metrics
    - ScheduledExecutorService scheduler
    + start()
    + stop()
    + isRunning(): boolean
  }

  class TaskRuntimeContext {
    - String planId
    - String taskId
    - String tenantId
    - boolean pauseRequested
    - boolean cancelRequested
    - Map<String, Object> attributes
    + injectMdc(stageName)
    + clearMdc()
    + isPauseRequested(): boolean
    + setPauseRequested(boolean)
  }

  interface TaskWorkerFactory {
    + create(planId, TaskAggregate, List<TaskStage>, ...): TaskExecutor
  }

  class DefaultTaskWorkerFactory {
    - MetricsRegistry metricsRegistry
    + create(...): TaskExecutor
  }

  TaskExecutor --> TaskAggregate
  TaskExecutor --> TaskStage
  TaskExecutor --> TaskRuntimeContext
  TaskExecutor --> HeartbeatScheduler
  TaskWorkerFactory <|.. DefaultTaskWorkerFactory
  DefaultTaskWorkerFactory ..> TaskExecutor
}

package "Orchestration" {
  class PlanOrchestrator {
    - TaskScheduler scheduler
    - ConflictRegistry conflicts
    - ExecutorProperties props
    + submitPlan(PlanAggregate, TaskWorkerFactory)
    + releaseTenantLock(tenantId)
  }

  class TaskScheduler {
    - ExecutorService pool
    - Set<String> running
    - Queue<String> waiting
    + schedule(taskId, maxConcurrency, worker): Future
  }

  class ConflictRegistry {
    - Map<String, String> tenantToTask
    + register(tenantId, taskId): boolean
    + release(tenantId)
    + getRunningTaskId(tenantId): String
  }

  PlanOrchestrator --> TaskScheduler
  PlanOrchestrator --> ConflictRegistry
}

package "Infrastructure" {
  interface CheckpointStore {
    + save(taskId, checkpoint)
    + load(taskId): TaskCheckpoint
    + loadMultiple(taskIds): Map<String, TaskCheckpoint>
    + remove(taskId)
  }

  class CheckpointService {
    - CheckpointStore store
    + saveCheckpoint(TaskAggregate, stageNames, index)
    + loadCheckpoint(TaskAggregate): TaskCheckpoint
    + loadMultiple(taskIds): Map
    + clearCheckpoint(TaskAggregate)
  }

  class InMemoryCheckpointStore {
    - Map<String, TaskCheckpoint> store
    + save/load/remove()
  }

  class RedisCheckpointStore {
    - RedisClient client
    - String namespace
    - long ttlSeconds
    + save/load/remove()
  }

  interface TaskEventSink {
    + publishTaskStarted(...)
    + publishTaskCompleted(...)
    + publishTaskFailed(...)
    + publishProgress(...)
    + publishStageStarted(...)
  }

  interface MetricsRegistry {
    + incrementCounter(name)
    + setGauge(name, value)
  }

  interface RollbackHealthVerifier {
    + verify(TaskAggregate, TaskRuntimeContext): boolean
  }

  CheckpointStore <|.. InMemoryCheckpointStore
  CheckpointStore <|.. RedisCheckpointStore
  CheckpointService --> CheckpointStore
}

package "Facade" {
  interface DeploymentTaskFacade {
    + createSwitchTask(configs): TaskCreationResult
    + pauseTaskByTenant(tenantId): TaskOperationResult
    + resumeTaskByTenant(tenantId): TaskOperationResult
    + retryTaskByTenant(tenantId, fromCheckpoint): TaskOperationResult
    + rollbackTaskByTenant(tenantId): TaskOperationResult
    + queryTaskStatus(taskId): TaskStatusInfo
  }

  class DeploymentTaskFacadeImpl {
    - ValidationChain validationChain
    - TaskStateManager stateManager
    - ExecutorProperties properties
    - HealthCheckClient healthCheckClient
    - PlanOrchestrator orchestrator
    + createSwitchTask(configs): TaskCreationResult
    + pauseTaskByTenant(tenantId): TaskOperationResult
    + ...
  }

  DeploymentTaskFacade <|.. DeploymentTaskFacadeImpl
  DeploymentTaskFacadeImpl --> TaskStateManager
  DeploymentTaskFacadeImpl --> PlanOrchestrator
}

' 跨包关系
TaskExecutor --> CheckpointService
TaskExecutor --> TaskEventSink
TaskExecutor --> MetricsRegistry
PlanOrchestrator --> TaskWorkerFactory
TaskStateManager --> TaskEventSink
TaskStateManager --> RollbackHealthVerifier

@enduml
@startuml 组件图
!theme plain

package "Facade Layer" {
  component [DeploymentTaskFacade] as Facade
  component [DeploymentTaskFacadeImpl] as FacadeImpl

  Facade <|.. FacadeImpl
}

package "Orchestration Layer" {
  component [PlanOrchestrator] as Orchestrator
  component [TaskScheduler] as Scheduler
  component [ConflictRegistry] as Conflict
}

package "Domain Layer" {
  package "Aggregate" {
    component [PlanAggregate] as PlanAgg
    component [TaskAggregate] as TaskAgg
  }

  package "State Machine" {
    component [TaskStateMachine] as TaskSM
    component [PlanStateMachine] as PlanSM
    component [TaskStateManager] as StateManager
  }

  package "Stage" {
    component [CompositeServiceStage] as Stage
    component [StageFactory] as StageFactory
    component [ConfigUpdateStep] as Step1
    component [BroadcastStep] as Step2
    component [HealthCheckStep] as Step3
  }

  package "Validation" {
    component [ValidationChain] as Validator
  }
}

package "Execution Layer" {
  component [TaskExecutor] as Executor
  component [TaskWorkerFactory] as WorkerFactory
  component [HeartbeatScheduler] as Heartbeat
}

package "Infrastructure Layer" {
  package "Checkpoint" {
    component [CheckpointService] as CPService
    interface "CheckpointStore" as CPStore
    component [InMemoryCheckpointStore] as MemoryCP
    component [RedisCheckpointStore] as RedisCP

    CPService --> CPStore
    CPStore <|.. MemoryCP
    CPStore <|.. RedisCP
  }

  package "Event" {
    interface "TaskEventSink" as EventSink
    component [SpringTaskEventSink] as SpringEvent
    component [NoopTaskEventSink] as NoopEvent

    EventSink <|.. SpringEvent
    EventSink <|.. NoopEvent
  }

  package "Health" {
    interface "HealthCheckClient" as HealthClient
    component [MockHealthCheckClient] as MockHealth
    component [RollbackHealthVerifier] as Verifier
  }

  package "Metrics" {
    interface "MetricsRegistry" as MetricsReg
    component [NoopMetricsRegistry] as NoopMetrics
    component [MicrometerMetricsRegistry] as MicrometerMetrics

    MetricsReg <|.. NoopMetrics
    MetricsReg <|.. MicrometerMetrics
  }

  package "Strategy" {
    interface "RollbackStrategy" as RBStrategy
    component [PreviousConfigRollbackStrategy] as PrevConfigRB

    RBStrategy <|.. PrevConfigRB
  }
}

package "Configuration" {
  component [ExecutorProperties] as Props
  component [ExecutorConfiguration] as Config
  component [ExecutorAutoConfiguration] as AutoConfig
}

package "Factory" {
  component [PlanFactory] as PlanFactory
}

' Facade 依赖关系
FacadeImpl --> Validator
FacadeImpl --> StateManager
FacadeImpl --> Props
FacadeImpl --> HealthClient
FacadeImpl --> Orchestrator
FacadeImpl --> PlanFactory

' Orchestration 依赖关系
Orchestrator --> Scheduler
Orchestrator --> Conflict
Orchestrator --> WorkerFactory
Orchestrator --> PlanAgg

' Factory 依赖关系
PlanFactory --> PlanAgg
PlanFactory --> TaskAgg
StageFactory --> Stage
StageFactory --> Step1
StageFactory --> Step2
StageFactory --> Step3
WorkerFactory --> Executor
WorkerFactory --> Heartbeat
WorkerFactory --> MetricsReg

' Scheduler 依赖关系
Scheduler --> Executor

' Executor 依赖关系
Executor --> TaskAgg
Executor --> Stage
Executor --> CPService
Executor --> EventSink
Executor --> StateManager
Executor --> Conflict
Executor --> MetricsReg
Executor --> Heartbeat

' StateManager 依赖关系
StateManager --> TaskSM
StateManager --> EventSink
StateManager --> TaskAgg
StateManager --> Verifier

' Stage 依赖关系
Stage --> Step1
Stage --> Step2
Stage --> Step3
Step3 --> HealthClient

' Rollback 依赖关系
RBStrategy --> TaskAgg
RBStrategy --> EventSink
PrevConfigRB --> Stage

' Configuration 依赖关系
Config --> Props
Config --> Validator
Config --> StateManager
Config --> HealthClient
Config --> FacadeImpl
AutoConfig --> Props
AutoConfig --> CPService
AutoConfig --> RedisCP

note right of Facade
  **对外统一接口**
  - createSwitchTask
  - pauseTask / resumeTask
  - retryTask / rollbackTask
  - queryTaskStatus
end note

note right of Orchestrator
  **计划编排器**
  - 提交 Plan
  - 路由任务到 Scheduler
  - 管理租户冲突
end note

note right of Scheduler
  **任务调度器**
  - 并发控制（maxConcurrency）
  - FIFO 队列
  - 任务提交与完成管理
end note

note right of StateManager
  **状态管理器**
  - 管理状态机实例
  - 执行状态转换
  - 发布状态事件
  - 维护 sequenceId
end note

note right of Executor
  **任务执行引擎**
  - 顺序执行 Stage
  - MDC 注入与清理
  - Checkpoint 保存恢复
  - 心跳调度
  - 指标收集
end note

note right of CPService
  **Checkpoint 服务**
  - 可插拔存储
  - 批量恢复
  - 终态清理
end note

note right of EventSink
  **事件发布**
  - Spring 集成
  - Noop 实现
  - 事件幂等性
end note

@enduml

