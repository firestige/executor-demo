@startuml 重试任务时序图
!theme plain
autonumber

actor "运维人员" as Operator
participant "DeploymentTaskFacade" as Facade
participant "TaskAggregate" as Task
participant "TaskStateManager" as StateManager
participant "CheckpointService" as Checkpoint
participant "TaskExecutor" as Executor
participant "TaskEventSink" as EventSink
participant "HeartbeatScheduler" as Heartbeat

Operator -> Facade: retryTaskByTenant(tenantId, fromCheckpoint=true)
activate Facade

Facade -> Facade: 查找租户的任务
Facade -> Task: getStatus()
Task --> Facade: FAILED

Facade -> Task: getRetryCount()
Task --> Facade: retryCount

Facade -> Task: getMaxRetry()
Task --> Facade: maxRetry

alt retryCount >= maxRetry
    Facade --> Operator: TaskOperationResult(failed, "超出最大重试次数")
    deactivate Facade
end

Facade -> Task: setRetryCount(retryCount + 1)

Facade -> StateManager: updateState(taskId, RUNNING)
activate StateManager

StateManager -> StateManager: 检查 Guard: retryCount < maxRetry
StateManager -> StateManager: 状态转换 FAILED -> RUNNING

StateManager -> EventSink: publishRetryStarted
activate EventSink
EventSink -> EventSink: 发布 TaskRetryStartedEvent
note right
  包含 fromCheckpoint 标志
end note
EventSink --> StateManager: published
deactivate EventSink

StateManager --> Facade: state updated
deactivate StateManager

alt fromCheckpoint = true
    Facade -> Checkpoint: loadCheckpoint(task)
    activate Checkpoint
    Checkpoint --> Facade: TaskCheckpoint(lastCompletedStageIndex)
    deactivate Checkpoint

    note right
      从 checkpoint 恢复：
      - 跳过已完成的 Stage
      - 从断点继续执行
    end note
else fromCheckpoint = false
    Facade -> Checkpoint: clearCheckpoint(taskId)
    activate Checkpoint
    Checkpoint --> Facade: cleared
    deactivate Checkpoint

    Facade -> Task: setCurrentStageIndex(0)

    note right
      完全重新执行：
      - 清空 checkpoint
      - 从第一个 Stage 开始
    end note
end

Facade -> Executor: execute() (重新提交)
activate Executor

Executor -> Checkpoint: loadCheckpoint(task)
activate Checkpoint

alt 有 checkpoint
    Checkpoint --> Executor: TaskCheckpoint(lastCompletedStageIndex=2)
    Executor -> Executor: startIndex = 3 (跳过已完成)
else 无 checkpoint
    Checkpoint --> Executor: null
    Executor -> Executor: startIndex = 0 (从头开始)
end
deactivate Checkpoint

alt fromCheckpoint = true
    Executor -> EventSink: publishProgress (补偿事件)
    activate EventSink
    EventSink -> EventSink: 发布 TaskProgressEvent
    note right
      补偿性进度事件，
      保证序列连续性
    end note
    EventSink --> Executor: published
    deactivate EventSink
end

Executor -> Heartbeat: start()
activate Heartbeat
note right
  重启心跳调度器
  (支持重复启动)
end note
Heartbeat --> Executor: started
deactivate Heartbeat

loop 从 startIndex 到 totalStages
    Executor -> Executor: execute(stage)
    Executor -> EventSink: publishStageStarted

    alt Stage 成功
        Executor -> Checkpoint: saveCheckpoint(task, stageIndex)
        activate Checkpoint
        Checkpoint --> Executor: saved
        deactivate Checkpoint
        Executor -> EventSink: publishStageCompleted
    else Stage 失败
        Executor -> EventSink: publishStageFailed
        Executor -> StateManager: updateState(taskId, FAILED)
        Executor --> Facade: TaskExecutionResult(failed)
    end
end

Executor -> StateManager: updateState(taskId, COMPLETED)
activate StateManager
StateManager -> EventSink: publishRetryCompleted
activate EventSink
EventSink -> EventSink: 发布 TaskRetryCompletedEvent
EventSink --> StateManager: published
deactivate EventSink

StateManager -> EventSink: publishTaskCompleted
StateManager --> Executor: state updated
deactivate StateManager

Executor -> Checkpoint: clearCheckpoint(taskId)
activate Checkpoint
Checkpoint --> Executor: cleared
deactivate Checkpoint

Executor --> Facade: TaskExecutionResult(success)
deactivate Executor

Facade --> Operator: TaskOperationResult(success)
deactivate Facade

@enduml
@startuml 用例视图
!theme plain
skinparam packageStyle rectangle

left to right direction

actor "运维人员" as Operator
actor "系统管理员" as Admin
actor "监控系统" as Monitor

rectangle "Executor System" {
  usecase "创建切换任务" as UC1
  usecase "暂停任务" as UC2
  usecase "恢复任务" as UC3
  usecase "取消任务" as UC4
  usecase "重试任务" as UC5
  usecase "回滚任务" as UC6
  usecase "查询任务状态" as UC7
  usecase "批量租户切换" as UC8

  package "内部机制" {
    usecase "租户冲突检测" as UC_CONFLICT
    usecase "并发控制" as UC_CONCURRENCY
    usecase "状态机管理" as UC_STATE
    usecase "Checkpoint保存恢复" as UC_CHECKPOINT
    usecase "健康检查验证" as UC_HEALTH
    usecase "心跳监控" as UC_HEARTBEAT
    usecase "事件发布" as UC_EVENT
    usecase "MDC日志上下文" as UC_MDC
  }
}

' 运维人员用例
Operator --> UC1
Operator --> UC2
Operator --> UC3
Operator --> UC4
Operator --> UC5
Operator --> UC6
Operator --> UC7

' 系统管理员用例
Admin --> UC8

' 监控系统用例
Monitor --> UC7
Monitor --> UC_HEARTBEAT
Monitor --> UC_EVENT

' 用例之间的关系
UC1 ..> UC_CONFLICT : <<include>>
UC1 ..> UC_STATE : <<include>>
UC1 ..> UC_CONCURRENCY : <<include>>

UC2 ..> UC_CHECKPOINT : <<include>>
UC2 ..> UC_STATE : <<include>>

UC3 ..> UC_CHECKPOINT : <<include>>
UC3 ..> UC_STATE : <<include>>

UC5 ..> UC_CHECKPOINT : <<include>>
UC5 ..> UC_STATE : <<include>>

UC6 ..> UC_STATE : <<include>>
UC6 ..> UC_HEALTH : <<include>>

UC8 ..> UC1 : <<extend>>
UC8 ..> UC_CONCURRENCY : <<include>>
UC8 ..> UC_CONFLICT : <<include>>

UC1 ..> UC_HEALTH : <<include>>
UC1 ..> UC_HEARTBEAT : <<include>>
UC1 ..> UC_EVENT : <<include>>
UC1 ..> UC_MDC : <<include>>

note right of UC_CONFLICT
  **租户冲突检测机制**
  - 同一租户不能有并发任务
  - 通过 ConflictRegistry 维护
  - 任务结束时释放锁
end note

note right of UC_CONCURRENCY
  **并发控制机制**
  - Plan 级 maxConcurrency
  - 超出阈值进入等待队列
  - FIFO 调度策略
end note

note right of UC_CHECKPOINT
  **Checkpoint 机制**
  - 每个 Stage 完成后保存
  - 支持从断点恢复
  - 可插拔存储（Memory/Redis）
end note

note right of UC_STATE
  **状态机管理**
  - 严格的状态转换规则
  - Guard 条件检查
  - Action 副作用执行
end note

@enduml

