# T-016 持久化方案决策讨论

> 任务: T-016  
> 阶段: 方案设计  
> 日期: 2025-11-23  
> 状态: **讨论中（待决策）**

---

## 1. 核心决策问题

### 1.1 首要问题：是否需要自动恢复？

| 选项 | 说明 | 影响 |
|------|------|------|
| **A. 需要自动恢复** | 系统重启后自动扫描并恢复执行中的任务 | → 必须持久化聚合状态 |
| **B. 依赖外部重试** | 外部系统检测崩溃，主动重新提交任务 | → 仅需 Checkpoint，保持轻量 |

**决策依据**：
- 任务平均执行时长？（< 1分钟 vs > 10分钟）
- 外部系统是否有重试能力？
- SLA 要求？（99% vs 99.99%）
- 是否多实例部署？

---

## 2. 状态持久化分析

### 2.1 需要持久化的状态分类

| 状态类别 | 当前存储 | 是否需要持久化 | 理由 |
|----------|----------|----------------|------|
| **1. 聚合核心状态** | InMemory | ⚠️ **待定** | 决定能否自动恢复 |
| **2. 执行运行态** | InMemory | ❌ **不需要** | 重启后重建 TaskExecutor 即可 |
| **3. Checkpoint** | Redis | ✅ **已持久化** | 断点恢复必需 |
| **4. 租户冲突锁** | InMemory | ⚠️ **待定** | 多实例需要，单实例可选 |
| **5. 领域事件** | InMemory | ⚠️ **待定** | 取决于审计要求 |

### 2.2 聚合状态细分（如果需要持久化）

#### Plan 聚合状态

| 字段 | 类型 | 是否持久化 | 持久化频率 | 理由 |
|------|------|------------|------------|------|
| planId | PlanId | ✅ 必须 | 创建时一次 | 主键 |
| status | PlanStatus | ✅ 必须 | 每次状态变更 | 判断是否需要恢复 |
| taskIds | List<TaskId> | ✅ 必须 | 创建/Task加入时 | Plan-Task 关联 |
| maxConcurrency | int | ✅ 必须 | 创建时一次 | 恢复编排器配置 |
| createdAt | LocalDateTime | ⚠️ 可选 | 创建时一次 | 审计 |
| startedAt | LocalDateTime | ⚠️ 可选 | 启动时一次 | 审计 |
| completedAt | LocalDateTime | ❌ 不需要 | - | 终态不需恢复 |
| progress | PlanProgress | ❌ 不需要 | - | 通过 Task 状态聚合计算 |

**Plan 状态持久化策略**：
- **何时写**：创建时、状态变更时（READY → RUNNING → COMPLETED/FAILED）
- **写入内容**：planId + status + taskIds + maxConcurrency（约 1KB）
- **存储结构**：Redis Hash `executor:plan:{planId}`
- **TTL**：7天（与 Checkpoint 一致）

---

#### Task 聚合状态

| 字段 | 类型 | 是否持久化 | 持久化频率 | 理由 |
|------|------|------------|------------|------|
| taskId | TaskId | ✅ 必须 | 创建时一次 | 主键 |
| tenantId | TenantId | ✅ 必须 | 创建时一次 | 租户锁、恢复查询 |
| planId | PlanId | ✅ 必须 | 创建时一次 | Plan-Task 关联 |
| status | TaskStatus | ✅ 必须 | 每次状态变更 | 判断是否需要恢复 |
| pauseRequested | boolean | ⚠️ 可选 | pause() 调用时 | 区分"暂停"还是"崩溃" |
| cancelRequested | boolean | ❌ 不需要 | - | 重启后默认不取消 |
| createdAt | LocalDateTime | ⚠️ 可选 | 创建时一次 | 审计 |
| startedAt | LocalDateTime | ⚠️ 可选 | 启动时一次 | 审计 |
| stageProgress | StageProgress | ❌ 不需要 | - | 通过 Checkpoint 恢复 |
| completedStages | List<StageResult> | ❌ 不需要 | - | 通过 Checkpoint 恢复 |
| retryPolicy | RetryPolicy | ⚠️ 可选 | 创建时一次 | 恢复重试逻辑 |
| tenantConfig | TenantDeployConfigSnapshot | ❌ 不需要 | - | 外部系统保存，重试时传入 |

**Task 状态持久化策略**：
- **何时写**：创建时、状态变更时（PENDING → RUNNING → COMPLETED/FAILED/PAUSED）
- **写入内容**：taskId + tenantId + planId + status + pauseRequested（约 500B）
- **存储结构**：Redis Hash `executor:task:{taskId}`
- **TTL**：7天

---

### 2.3 运行态数据（不持久化）

| 数据 | 理由 | 恢复方式 |
|------|------|----------|
| **TaskExecutor 实例** | 线程上下文无法序列化 | 重启时根据聚合状态重建 |
| **HeartbeatScheduler** | 调度器状态易失 | 重建 TaskExecutor 时自动创建 |
| **线程池** | JVM 管理 | Spring 重启时自动创建 |
| **Semaphore** | 本地计数器 | 重启时根据 Plan.maxConcurrency 重建 |

---

## 3. 持久化的时间边界

### 3.1 持久化时机分析

| 时机 | 触发条件 | 写入内容 | 频率 | 性能影响 |
|------|----------|----------|------|----------|
| **聚合创建** | Plan/Task 创建时 | 全部字段 | 低（一次） | ✅ 低 |
| **状态变更** | status 字段变化 | status + timestamp | 中（每个状态转换） | ✅ 低 |
| **Stage 完成** | completeStage() | 无（已有 Checkpoint） | 高（每个 Stage） | ✅ 低（仅 Checkpoint） |
| **暂停请求** | pauseTaskByTenant() | pauseRequested=true | 极低 | ✅ 低 |
| **心跳** | 每 10s | ❌ 不写 | 极高 | ⚠️ 不建议持久化 |

**推荐策略**：
- ✅ 创建时写入
- ✅ 状态变更时写入
- ❌ 心跳不写入（频率太高）
- ⚠️ 暂停/取消标志可选（根据业务需求）

### 3.2 TTL 策略

| 数据类型 | TTL | 理由 |
|----------|-----|------|
| **Plan 状态** | 7天 | 与 Checkpoint 一致，过期自动清理 |
| **Task 状态** | 7天 | 同上 |
| **Checkpoint** | 7天 | 已有策略 |
| **租户锁** | 10分钟 | 短期锁，防泄漏（如果持久化） |

---

## 4. 持久化的空间边界

### 4.1 存储容量估算

**假设**：
- 单个 Plan：10 个 Task
- 单个 Task 持久化数据：500 Bytes
- 单个 Plan 持久化数据：1 KB
- 并发执行：100 个 Plan

**存储需求**：
- Task 状态：10 × 100 × 500B = 500KB
- Plan 状态：100 × 1KB = 100KB
- Checkpoint：10 × 100 × 2KB = 2MB（假设 Checkpoint 2KB）
- **总计**：约 2.6 MB（可忽略不计）

**结论**：存储空间不是瓶颈。

### 4.2 Redis Key 设计

| Key 模式 | 示例 | 数据结构 | 说明 |
|----------|------|----------|------|
| `executor:plan:{planId}` | executor:plan:plan-123 | Hash | Plan 状态字段 |
| `executor:task:{taskId}` | executor:task:task-456 | Hash | Task 状态字段 |
| `executor:ckpt:{taskId}` | executor:ckpt:task-456 | String | Checkpoint JSON（已有） |
| `executor:index:plan:running` | - | Set | 索引：RUNNING 状态的 PlanId |
| `executor:index:task:running` | - | Set | 索引：RUNNING 状态的 TaskId |
| `executor:lock:tenant:{tenantId}` | executor:lock:tenant:t-001 | String | 租户锁（可选） |

**索引用途**：
- 重启时快速扫描需要恢复的任务（SMEMBERS executor:index:task:running）
- 无需全量扫描 Redis

---

## 5. 影响选型的其他条件

### 5.1 性能要求

| 维度 | 影响 | 说明 |
|------|------|------|
| **写入频率** | 中等 | 状态变更频率 = 任务生命周期状态转换次数（约 10次/任务） |
| **Redis 延迟** | 低 | 单次 HSET 约 1ms，可接受 |
| **批量写入** | 可选 | 使用 Pipeline 批量写入 Plan + Task 状态 |
| **同步 vs 异步** | 同步优先 | 状态变更需要立即持久化，异步可能崩溃前丢失 |

**性能优化手段**：
- Pipeline 批量写入（Plan + Tasks）
- 本地缓存读取（避免频繁查 Redis）
- 异步删除（任务完成后清理，可延迟）

### 5.2 一致性要求

| 场景 | 一致性级别 | 策略 |
|------|------------|------|
| **聚合 + Checkpoint** | 最终一致 | 两次写入，允许短暂不一致 |
| **状态索引** | 最终一致 | 状态变更后更新索引（可异步） |
| **租户锁** | 强一致（如果多实例） | Redis SET NX + TTL |

**风险**：
- 聚合状态写入成功，Checkpoint 写入失败 → 重试时从头执行（可接受）
- Checkpoint 写入成功，聚合状态写入失败 → 重启时无法识别需要恢复（⚠️ 需要事务）

**解决方案**：
- 使用 Redis Transaction（MULTI/EXEC）保证原子性
- 或先写 Checkpoint，再写聚合状态（失败则清理 Checkpoint）

### 5.3 多实例部署

| 问题 | 单实例 | 多实例 | 解决方案 |
|------|--------|--------|----------|
| **租户锁** | 本地 Map 可用 | ❌ 锁不共享 | Redis SET NX + TTL |
| **任务恢复** | 单实例扫描恢复 | ⚠️ 需要分布式协调 | Leader 选举 + 分片恢复 |
| **Checkpoint 竞争** | 无竞争 | ⚠️ 多实例可能覆盖 | 增加 version 字段 + CAS |

**当前假设**：单实例部署，多实例为未来演进。

### 5.4 恢复策略

| 策略 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **启动时全量扫描** | 扫描所有 RUNNING 状态的 Task，逐个恢复 | 简单、完整 | 启动慢（如果任务多） |
| **定期扫描** | 后台定期扫描"僵尸"任务（长时间无心跳） | 不影响启动速度 | 恢复延迟 |
| **外部触发** | 外部系统检测崩溃，调用恢复 API | 灵活、可控 | 依赖外部系统 |

**推荐**：启动时全量扫描（任务数量可控，通常 < 1000）

---

## 6. 方案对比（基于条件）

### 方案 A：聚合全量持久化

**适用条件**：
- ✅ 需要自动恢复
- ✅ 长任务（> 10分钟）
- ✅ 高 SLA（99.9%+）
- ⚠️ 单实例或有分布式协调

**实施要点**：
- Task/Plan 聚合所有字段序列化 JSON 存 Redis
- 状态变更、Stage 完成时都写入
- 重启时全量扫描恢复

**性能评估**：
- 写入频率：高（每个 Stage 完成都写）
- 写入大小：大（聚合完整对象 2-5KB）
- Redis 负载：中等

---

### 方案 B：核心状态持久化（推荐）

**适用条件**：
- ✅ 需要自动恢复
- ✅ 中短任务（1-10分钟）
- ✅ 中等 SLA（99%）
- ✅ 单实例

**实施要点**：
- 仅持久化核心字段（taskId、tenantId、planId、status）
- Checkpoint 已有，不重复写
- 运行态（StageProgress、completedStages）通过 Checkpoint 恢复

**性能评估**：
- 写入频率：低（仅状态变更）
- 写入大小：小（500B）
- Redis 负载：低

**对比方案 A 的优势**：
- ✅ 性能开销低 10 倍
- ✅ 存储空间小 5 倍
- ✅ 仍支持自动恢复

---

### 方案 C：外部重试（当前架构）

**适用条件**：
- ❌ 不需要自动恢复
- ✅ 短任务（< 1分钟）
- ✅ 低 SLA（95%）
- ✅ 有外部编排系统

**实施要点**：
- 保持当前架构（仅 Checkpoint 持久化）
- 外部系统维护任务状态
- 检测崩溃后主动重试

**性能评估**：
- 写入频率：极低（仅 Checkpoint）
- Redis 负载：极低

**风险**：
- ⚠️ 依赖外部系统可靠性
- ⚠️ 恢复延迟（外部检测 + 重试）
- ⚠️ 双写状态（外部系统需维护任务 ID）

---

## 7. 关键决策点总结

### 决策 1：是否需要自动恢复？

**问题**：系统重启后，是否需要自动检测并恢复执行中的任务？

**选项**：
- A. 需要（→ 方案 B 或 A）
- B. 不需要，依赖外部重试（→ 方案 C，保持当前架构）

**决策依据**：
- [ ] 任务平均执行时长：______ 秒
- [ ] 外部系统是否有重试能力：是 / 否
- [ ] SLA 要求：_____%
- [ ] 预期崩溃频率：______ 次/月

---

### 决策 2：如果需要自动恢复，持久化哪些状态？

**问题**：是全量聚合还是核心字段？

**选项**：
- A. 全量聚合（方案 A）
- B. 核心状态（方案 B，**推荐**）

**决策依据**：
- [ ] 任务执行时长：< 1min / 1-10min / > 10min
- [ ] 并发任务数：< 100 / 100-1000 / > 1000
- [ ] Redis 容量：充足 / 有限

**推荐**：除非任务极长（> 30分钟），否则选方案 B。

---

### 决策 3：租户锁是否持久化？

**问题**：租户互斥锁是否需要跨实例共享？

**选项**：
- A. 持久化（Redis SET NX）
- B. 保持内存（当前架构）

**决策依据**：
- [ ] 是否多实例部署：是 / 否
- [ ] 崩溃后是否允许租户重复执行：是 / 否

**推荐**：
- 单实例 → 保持内存（简单）
- 多实例 → 必须持久化

---

### 决策 4：事件是否持久化？

**问题**：领域事件是否需要持久化以保证可靠投递？

**选项**：
- A. 持久化（Redis Stream / Kafka）
- B. 保持内存（当前架构）

**决策依据**：
- [ ] 是否有审计要求：是 / 否
- [ ] 外部监听器是否容错：是 / 否
- [ ] 事件丢失是否可接受：是 / 否

**推荐**：
- 短期 → 保持内存（简单）
- 长期 → 持久化（高可靠）

---

## 8. 下一步行动

### 阶段 1：决策（当前）

- [ ] 确认业务 SLA 要求
- [ ] 评估任务平均执行时长
- [ ] 确认是否多实例部署
- [ ] 选择方案（A / B / C）

### 阶段 2：详细设计（决策后）

- [ ] 设计 Redis Key 结构
- [ ] 设计状态写入时机（同步/异步）
- [ ] 设计恢复扫描逻辑
- [ ] 设计异常处理与降级策略

### 阶段 3：实施（设计完成后）

- [ ] 实现 Repository 持久化适配器
- [ ] 实现启动时扫描恢复逻辑
- [ ] 实现租户锁（如果需要）
- [ ] 补充单元测试与集成测试

### 阶段 4：验证

- [ ] 压力测试（并发任务、崩溃恢复）
- [ ] 性能测试（Redis 写入延迟、恢复时间）
- [ ] 容错测试（Redis 故障、恢复失败）

---

## 9. 待讨论问题

1. **任务平均执行时长是多少？**
   - 影响：决定是否需要自动恢复

2. **外部系统是否维护任务状态？**
   - 影响：是否可以依赖外部重试

3. **SLA 要求是多少？**
   - 影响：方案复杂度与成本

4. **是否有多实例部署计划？**
   - 影响：租户锁、任务恢复分片策略

5. **Redis 容量和性能是否充足？**
   - 影响：持久化粒度（全量 vs 核心字段）

6. **是否接受事件丢失？**
   - 影响：事件持久化策略

---

> **当前状态**：等待业务方反馈，确认决策依据，然后进入详细设计阶段。

